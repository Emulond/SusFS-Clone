From c14cf70ddf78c8da59916ffab9aea1a6ad61b581 Mon Sep 17 00:00:00 2001
From: "Christopher A. Williamson" <home@chrisaw.com>
Date: Sat, 22 Jun 2024 21:51:05 +0100
Subject: [PATCH] Add SUSFS in kernel

---
 fs/Makefile           |   2 +
 fs/namei.c            | 116 ++++++++++++++++++++++++++++++++++++++++++
 fs/open.c             |  46 +++++++++++++++++
 fs/proc/base.c        |   9 ++++
 fs/proc/task_mmu.c    |  23 +++++++++
 fs/proc_namespace.c   |  43 +++++++++++++++-
 fs/readdir.c          |  11 ++++
 fs/stat.c             |  15 ++++++
 include/linux/mount.h |   4 ++
 kernel/sys.c          |   9 ++++
 10 files changed, 276 insertions(+), 2 deletions(-)

diff --git a/fs/Makefile b/fs/Makefile
index c7851875b..e951f5487 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -18,6 +18,8 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		fs_types.o fs_context.o fs_parser.o fsopen.o init.o \
 		kernel_read_file.o remap_range.o
 
+obj-$(CONFIG_KSU_SUSFS) += susfs.o
+
 ifeq ($(CONFIG_BLOCK),y)
 obj-y +=	buffer.o block_dev.o direct-io.o mpage.o
 else
diff --git a/fs/namei.c b/fs/namei.c
index fefbee51f..5bc0ce8ce 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -43,6 +43,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #define CREATE_TRACE_POINTS
 #include <trace/events/namei.h>
 
@@ -3532,6 +3536,13 @@ struct file *do_filp_open(int dfd, struct filename *pathname,
 	int flags = op->lookup_flags;
 	struct file *filp;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int error;
+	if (susfs_sus_path_by_filename(pathname, &error, SYSCALL_FAMILY_ALL_ENOENT)) {
+		return ERR_PTR(error);
+	}
+#endif
+
 	set_nameidata(&nd, dfd, pathname);
 	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
 	if (unlikely(filp == ERR_PTR(-ECHILD)))
@@ -3722,6 +3733,19 @@ static long do_mknodat(int dfd, const char __user *filename, umode_t mode,
 	int error;
 	unsigned int lookup_flags = 0;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_MKNOD);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	error = may_mknod(mode);
 	if (error)
 		return error;
@@ -3801,6 +3825,19 @@ static long do_mkdirat(int dfd, const char __user *pathname, umode_t mode)
 	int error;
 	unsigned int lookup_flags = LOOKUP_DIRECTORY;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(pathname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_MKDIRAT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 retry:
 	dentry = user_path_create(dfd, pathname, &path, lookup_flags);
 	if (IS_ERR(dentry))
@@ -3875,6 +3912,18 @@ long do_rmdir(int dfd, struct filename *name)
 	struct qstr last;
 	int type;
 	unsigned int lookup_flags = 0;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(name, &error, SYSCALL_FAMILY_RMDIR);
+
+	if (status) {
+		return error;
+	}
+	error = 0;
+#endif
+
 retry:
 	name = filename_parentat(dfd, name, lookup_flags,
 				&path, &last, &type);
@@ -4006,6 +4055,7 @@ long do_unlinkat(int dfd, struct filename *name)
 	struct inode *inode = NULL;
 	struct inode *delegated_inode = NULL;
 	unsigned int lookup_flags = 0;
+
 retry:
 	name = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
 	if (IS_ERR(name))
@@ -4112,6 +4162,19 @@ static long do_symlinkat(const char __user *oldname, int newdfd,
 	struct path path;
 	unsigned int lookup_flags = 0;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(newname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_SYMLINKAT_NEWNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	from = getname(oldname);
 	if (IS_ERR(from))
 		return PTR_ERR(from);
@@ -4243,6 +4306,27 @@ static int do_linkat(int olddfd, const char __user *oldname, int newdfd,
 	int how = 0;
 	int error;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(oldname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_LINKAT_OLDNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+
+	fname = getname_safe(newname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_LINKAT_NEWNAME);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0)
 		return -EINVAL;
 	/*
@@ -4523,6 +4607,22 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 	bool should_retry = false;
 	int error = -EINVAL;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+int status;
+
+status = susfs_sus_path_by_filename(from, &error, SYSCALL_FAMILY_RENAMEAT2_OLDNAME);
+
+if (status) {
+    return error;
+}
+
+status = susfs_sus_path_by_filename(to, &error, SYSCALL_FAMILY_RENAMEAT2_NEWNAME);
+
+if (status) {
+    return error;
+}
+#endif
+
 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
 		goto put_both;
 
@@ -4541,6 +4641,13 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 		goto put_new;
 	}
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	status = susfs_sus_path_by_filename(from, &error, SYSCALL_FAMILY_RENAMEAT2_OLDNAME);
+	if (status) {
+		goto exit;
+	}
+#endif
+
 	to = filename_parentat(newdfd, to, lookup_flags, &new_path, &new_last,
 				&new_type);
 	if (IS_ERR(to)) {
@@ -4548,6 +4655,13 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 		goto exit1;
 	}
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	status = susfs_sus_path_by_filename(to, &error, SYSCALL_FAMILY_RENAMEAT2_NEWNAME);
+	if (status) {
+		goto exit;
+	}
+#endif
+
 	error = -EXDEV;
 	if (old_path.mnt != new_path.mnt)
 		goto exit2;
@@ -4642,6 +4756,8 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 		lookup_flags |= LOOKUP_REVAL;
 		goto retry;
 	}
+exit:
+	return error;
 put_both:
 	if (!IS_ERR(from))
 		putname(from);
diff --git a/fs/open.c b/fs/open.c
index 965230a07..94b5628d1 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -34,6 +34,11 @@
 #include <linux/compat.h>
 
 #include "internal.h"
+
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include <trace/hooks/syscall_check.h>
 
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
@@ -125,6 +130,19 @@ long do_sys_truncate(const char __user *pathname, loff_t length)
 	struct path path;
 	int error;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(pathname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (length < 0)	/* sorry, but loff_t says... */
 		return -EINVAL;
 
@@ -403,6 +421,20 @@ static long do_faccessat(int dfd, const char __user *filename, int mode, int fla
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 	const struct cred *old_cred = NULL;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+	int error;
+
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
 
@@ -488,6 +520,20 @@ SYSCALL_DEFINE1(chdir, const char __user *, filename)
 	struct path path;
 	int error;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 retry:
 	error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
 	if (error)
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 283df1444..2abd96f5c 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -103,6 +103,10 @@
 
 #include "../../lib/kstrtox.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /* NOTE:
  *	Implementing inode permission operations in /proc is almost
  *	certainly an error.  Permission checks need to happen during
@@ -1775,6 +1779,11 @@ static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)
 
 	if (len > buflen)
 		len = buflen;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+	susfs_sus_proc_fd_link(pathname, len);
+#endif
+
 	if (copy_to_user(buffer, pathname, len))
 		len = -EFAULT;
  out:
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index 7e70972b2..71aa8e35b 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -27,6 +27,10 @@
 #include <asm/tlbflush.h>
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #define SEQ_PUT_DEC(str, val) \
 		seq_put_decimal_ull_width(m, str, (val) << (PAGE_SHIFT-10), 8)
 void task_mem(struct seq_file *m, struct mm_struct *mm)
@@ -281,6 +285,11 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 	dev_t dev = 0;
 	const char *name = NULL;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	char tmpname[SUSFS_MAX_LEN_PATHNAME];
+	int ret = 0;
+#endif
+
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
 		dev = inode->i_sb->s_dev;
@@ -290,8 +299,22 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 
 	start = vma->vm_start;
 	end = vma->vm_end;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	ret = susfs_sus_maps(ino, end - start, &ino, &dev, &flags, &pgoff, vma, tmpname);
+#endif
+
 	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (ret == 2) {
+		seq_pad(m, ' ');
+		seq_puts(m, tmpname);
+		seq_putc(m, '\n');
+		return;
+	}
+#endif
+
 	/*
 	 * Print the dentry name for named mappings, and a
 	 * special [heap] marker for the heap:
diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c
index eafb75755..e987e092c 100644
--- a/fs/proc_namespace.c
+++ b/fs/proc_namespace.c
@@ -18,6 +18,10 @@
 #include "pnode.h"
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 static __poll_t mounts_poll(struct file *file, poll_table *wait)
 {
 	struct seq_file *m = file->private_data;
@@ -103,6 +107,10 @@ static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root)) return 0;
+#endif
+
 	if (sb->s_op->show_devname) {
 		err = sb->s_op->show_devname(m, mnt_path.dentry);
 		if (err)
@@ -137,8 +145,25 @@ static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)
 	struct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root)) return 0;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (!uid_matches_proc_need_to_reorder_mnt_id()) goto orig_flow;
+
+	seq_printf(m, "%i %i %u:%u ",
+		susfs_get_fake_mnt_id(r->mnt_id),
+		susfs_get_fake_mnt_id(r->mnt_parent->mnt_id),
+		MAJOR(sb->s_dev), MINOR(sb->s_dev));
+	goto bypass_orig_flow;
+orig_flow:
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 	seq_printf(m, "%i %i %u:%u ", r->mnt_id, r->mnt_parent->mnt_id,
-		   MAJOR(sb->s_dev), MINOR(sb->s_dev));
+		MAJOR(sb->s_dev), MINOR(sb->s_dev));
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+bypass_orig_flow:
+#endif
 	if (sb->s_op->show_path) {
 		err = sb->s_op->show_path(m, mnt->mnt_root);
 		if (err)
@@ -199,6 +224,10 @@ static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root)) return 0;
+#endif
+
 	/* device */
 	if (sb->s_op->show_devname) {
 		seq_puts(m, "device ");
@@ -237,7 +266,7 @@ static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)
 }
 
 static int mounts_open_common(struct inode *inode, struct file *file,
-			      int (*show)(struct seq_file *, struct vfsmount *))
+				int (*show)(struct seq_file *, struct vfsmount *))
 {
 	struct task_struct *task = get_proc_task(inode);
 	struct nsproxy *nsp;
@@ -300,6 +329,11 @@ static int mounts_release(struct inode *inode, struct file *file)
 	path_put(&p->root);
 	mnt_cursor_del(p->ns, &p->cursor);
 	put_mnt_ns(p->ns);
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (uid_matches_proc_need_to_reorder_mnt_id()) {
+		susfs_remove_mnt_id_recorder();
+	}
+#endif
 	return seq_release_private(inode, file);
 }
 
@@ -310,6 +344,11 @@ static int mounts_open(struct inode *inode, struct file *file)
 
 static int mountinfo_open(struct inode *inode, struct file *file)
 {
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (uid_matches_proc_need_to_reorder_mnt_id()) {
+		susfs_add_mnt_id_recorder();
+	}
+#endif
 	return mounts_open_common(inode, file, show_mountinfo);
 }
 
diff --git a/fs/readdir.c b/fs/readdir.c
index 09e8ed7d4..f56e7d99e 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -22,6 +22,10 @@
 #include <linux/compat.h>
 #include <linux/uaccess.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include <asm/unaligned.h>
 
 /*
@@ -326,6 +330,13 @@ static int filldir64(struct dir_context *ctx, const char *name, int namlen,
 	prev_reclen = buf->prev_reclen;
 	if (prev_reclen && signal_pending(current))
 		return -EINTR;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+        if (susfs_sus_ino_for_filldir64(ino)) {
+                return 0;
+        }
+#endif
+
 	dirent = buf->current_dir;
 	prev = (void __user *)dirent - prev_reclen;
 	if (!user_write_access_begin(prev, reclen + prev_reclen))
diff --git a/fs/stat.c b/fs/stat.c
index c6a2e1098..c459ae482 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -21,6 +21,10 @@
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include "internal.h"
 #include "mount.h"
 
@@ -126,6 +130,12 @@ int vfs_getattr(const struct path *path, struct kstat *stat,
 {
 	int retval;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (susfs_sus_path_by_path(path, &retval, SYSCALL_FAMILY_ALL_ENOENT)) {
+		return retval;
+	}
+#endif
+
 	retval = security_inode_getattr(path);
 	if (retval)
 		return retval;
@@ -346,6 +356,11 @@ static int cp_new_stat(struct kstat *stat, struct stat __user *statbuf)
 #endif
 	tmp.st_blocks = stat->blocks;
 	tmp.st_blksize = stat->blksize;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+	susfs_sus_kstat(tmp.st_ino, &tmp);
+#endif
+
 	return copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;
 }
 
diff --git a/include/linux/mount.h b/include/linux/mount.h
index 2f64e66f9..1a5e98787 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -116,6 +116,10 @@ extern dev_t name_to_dev_t(const char *name);
 
 extern unsigned int sysctl_mount_max;
 
+#ifdef CONFIG_KSU_SUSFS
+extern int path_umount(struct path *path, int flags);
+#endif
+
 extern bool path_is_mountpoint(const struct path *path);
 
 extern void kern_unmount_array(struct vfsmount *mnt[], unsigned int num);
diff --git a/kernel/sys.c b/kernel/sys.c
index 4e9627616..977f72006 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -73,6 +73,10 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include "uid16.h"
 
 #include <trace/hooks/sys.h>
@@ -1277,6 +1281,11 @@ SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
 	down_read(&uts_sem);
 	memcpy(&tmp, utsname(), sizeof(tmp));
 	up_read(&uts_sem);
+
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+	susfs_spoof_uname(&tmp);
+#endif
+
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
 
-- 
2.44.1

