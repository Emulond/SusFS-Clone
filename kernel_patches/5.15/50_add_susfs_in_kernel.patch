From 24178dc00850cd34353942db0bc9d40a2ecb69be Mon Sep 17 00:00:00 2001
From: Android Build <androidbuild@localhost>
Date: Fri, 21 Jun 2024 23:12:05 +0100
Subject: [PATCH] Add SUSFS in kernel

---
 fs/Makefile           |   2 +
 fs/namei.c            | 101 ++++++++++++++++++++++++++++++++++++++++++
 fs/open.c             |  46 +++++++++++++++++++
 fs/proc/base.c        |   9 ++++
 fs/proc/task_mmu.c    |  23 ++++++++++
 fs/proc_namespace.c   |  41 ++++++++++++++++-
 fs/readdir.c          |  11 +++++
 fs/stat.c             |  15 +++++++
 include/linux/mount.h |   4 ++
 kernel/sys.c          |   9 ++++
 10 files changed, 260 insertions(+), 1 deletion(-)

diff --git a/fs/Makefile b/fs/Makefile
index e4adb9882..2461d8986 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -18,6 +18,8 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		fs_types.o fs_context.o fs_parser.o fsopen.o init.o \
 		kernel_read_file.o remap_range.o
 
+obj-$(CONFIG_KSU_SUSFS) += susfs.o
+
 ifeq ($(CONFIG_BLOCK),y)
 obj-y +=	buffer.o direct-io.o mpage.o
 else
diff --git a/fs/namei.c b/fs/namei.c
index a3922d96f..6edd5b74e 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -43,6 +43,10 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /* [Feb-1997 T. Schoebel-Theuer]
  * Fundamental changes in the pathname lookup mechanisms (namei)
  * were necessary because of omirr.  The reason is that omirr needs
@@ -3765,6 +3769,13 @@ struct file *do_filp_open(int dfd, struct filename *pathname,
 	int flags = op->lookup_flags;
 	struct file *filp;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int error;
+	if (susfs_sus_path_by_filename(pathname, &error, SYSCALL_FAMILY_ALL_ENOENT)) {
+		return ERR_PTR(error);
+	}
+#endif
+
 	set_nameidata(&nd, dfd, pathname, NULL);
 	filp = path_openat(&nd, op, flags | LOOKUP_RCU);
 	if (unlikely(filp == ERR_PTR(-ECHILD)))
@@ -3974,6 +3985,16 @@ static int do_mknodat(int dfd, struct filename *name, umode_t mode,
 	int error;
 	unsigned int lookup_flags = 0;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(name, &error, SYSCALL_FAMILY_MKNOD);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	error = may_mknod(mode);
 	if (error)
 		goto out1;
@@ -4076,6 +4097,16 @@ int do_mkdirat(int dfd, struct filename *name, umode_t mode)
 	int error;
 	unsigned int lookup_flags = LOOKUP_DIRECTORY;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(name, &error, SYSCALL_FAMILY_MKDIRAT);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 retry:
 	dentry = filename_create(dfd, name, &path, lookup_flags);
 	error = PTR_ERR(dentry);
@@ -4173,6 +4204,18 @@ int do_rmdir(int dfd, struct filename *name)
 	struct qstr last;
 	int type;
 	unsigned int lookup_flags = 0;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(name, &error, SYSCALL_FAMILY_RMDIR);
+
+	if (status) {
+		return error;
+	}
+	error = 0;
+#endif
+
 retry:
 	error = filename_parentat(dfd, name, lookup_flags, &path, &last, &type);
 	if (error)
@@ -4440,6 +4483,16 @@ int do_symlinkat(struct filename *from, int newdfd, struct filename *to)
 	struct path path;
 	unsigned int lookup_flags = 0;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(to, &error, SYSCALL_FAMILY_SYMLINKAT_NEWNAME);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (IS_ERR(from)) {
 		error = PTR_ERR(from);
 		goto out_putnames;
@@ -4588,6 +4641,22 @@ int do_linkat(int olddfd, struct filename *old, int newdfd,
 	int how = 0;
 	int error;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(old, &error, SYSCALL_FAMILY_LINKAT_OLDNAME);
+
+	if (status) {
+		return error;
+	}
+
+	status = susfs_sus_path_by_filename(new, &error, SYSCALL_FAMILY_LINKAT_NEWNAME);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if ((flags & ~(AT_SYMLINK_FOLLOW | AT_EMPTY_PATH)) != 0) {
 		error = -EINVAL;
 		goto out_putnames;
@@ -4882,6 +4951,22 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 	bool should_retry = false;
 	int error = -EINVAL;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	int status;
+
+	status = susfs_sus_path_by_filename(from, &error, SYSCALL_FAMILY_RENAMEAT2_OLDNAME);
+
+	if (status) {
+		return error;
+	}
+
+	status = susfs_sus_path_by_filename(to, &error, SYSCALL_FAMILY_RENAMEAT2_NEWNAME);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))
 		goto put_names;
 
@@ -4898,11 +4983,25 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 	if (error)
 		goto put_names;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	status = susfs_sus_path_by_filename(from, &error, SYSCALL_FAMILY_RENAMEAT2_OLDNAME);
+	if (status) {
+		goto exit;
+	}
+#endif
+
 	error = filename_parentat(newdfd, to, lookup_flags, &new_path, &new_last,
 				  &new_type);
 	if (error)
 		goto exit1;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	status = susfs_sus_path_by_filename(to, &error, SYSCALL_FAMILY_RENAMEAT2_NEWNAME);
+	if (status) {
+		goto exit;
+	}
+#endif
+
 	error = -EXDEV;
 	if (old_path.mnt != new_path.mnt)
 		goto exit2;
@@ -5006,6 +5105,8 @@ int do_renameat2(int olddfd, struct filename *from, int newdfd,
 		lookup_flags |= LOOKUP_REVAL;
 		goto retry;
 	}
+exit:
+	return error;
 put_names:
 	putname(from);
 	putname(to);
diff --git a/fs/open.c b/fs/open.c
index acb11b3eb..3a89601fd 100644
--- a/fs/open.c
+++ b/fs/open.c
@@ -35,6 +35,11 @@
 #include <linux/mnt_idmapping.h>
 
 #include "internal.h"
+
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include <trace/hooks/syscall_check.h>
 
 int do_truncate(struct user_namespace *mnt_userns, struct dentry *dentry,
@@ -126,6 +131,19 @@ long do_sys_truncate(const char __user *pathname, loff_t length)
 	struct path path;
 	int error;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(pathname);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (length < 0)	/* sorry, but loff_t says... */
 		return -EINVAL;
 
@@ -402,6 +420,20 @@ static long do_faccessat(int dfd, const char __user *filename, int mode, int fla
 	unsigned int lookup_flags = LOOKUP_FOLLOW;
 	const struct cred *old_cred = NULL;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+	int error;
+
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
 
@@ -487,6 +519,20 @@ SYSCALL_DEFINE1(chdir, const char __user *, filename)
 	struct path path;
 	int error;
 	unsigned int lookup_flags = LOOKUP_FOLLOW | LOOKUP_DIRECTORY;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	struct filename* fname;
+	int status;
+
+	fname = getname_safe(filename);
+	status = susfs_sus_path_by_filename(fname, &error, SYSCALL_FAMILY_ALL_ENOENT);
+	putname_safe(fname);
+
+	if (status) {
+		return error;
+	}
+#endif
+
 retry:
 	error = user_path_at(AT_FDCWD, filename, lookup_flags, &path);
 	if (error)
diff --git a/fs/proc/base.c b/fs/proc/base.c
index 57aafb74d..07308397c 100644
--- a/fs/proc/base.c
+++ b/fs/proc/base.c
@@ -105,6 +105,10 @@
 
 #include "../../lib/kstrtox.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 /* NOTE:
  *	Implementing inode permission operations in /proc is almost
  *	certainly an error.  Permission checks need to happen during
@@ -1792,6 +1796,11 @@ static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)
 
 	if (len > buflen)
 		len = buflen;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PROC_FD_LINK
+	susfs_sus_proc_fd_link(pathname, len);
+#endif
+
 	if (copy_to_user(buffer, pathname, len))
 		len = -EFAULT;
  out:
diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c
index e429aadc3..d38b881b2 100644
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -27,6 +27,10 @@
 #include <asm/tlbflush.h>
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #define SEQ_PUT_DEC(str, val) \
 		seq_put_decimal_ull_width(m, str, (val) << (PAGE_SHIFT-10), 8)
 void task_mem(struct seq_file *m, struct mm_struct *mm)
@@ -281,6 +285,11 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 	dev_t dev = 0;
 	const char *name = NULL;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	char tmpname[SUSFS_MAX_LEN_PATHNAME];
+	int ret = 0;
+#endif
+
 	if (file) {
 		struct inode *inode = file_inode(vma->vm_file);
 		dev = inode->i_sb->s_dev;
@@ -290,8 +299,22 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
 
 	start = vma->vm_start;
 	end = vma->vm_end;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	ret = susfs_sus_maps(ino, end - start, &ino, &dev, &flags, &pgoff, vma, tmpname);
+#endif
+
 	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MAPS
+	if (ret == 2) {
+		seq_pad(m, ' ');
+		seq_puts(m, tmpname);
+		seq_putc(m, '\n');
+		return;
+	}
+#endif
+
 	/*
 	 * Print the dentry name for named mappings, and a
 	 * special [heap] marker for the heap:
diff --git a/fs/proc_namespace.c b/fs/proc_namespace.c
index 49650e54d..1c38fa07b 100644
--- a/fs/proc_namespace.c
+++ b/fs/proc_namespace.c
@@ -18,6 +18,10 @@
 #include "pnode.h"
 #include "internal.h"
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 static __poll_t mounts_poll(struct file *file, poll_table *wait)
 {
 	struct seq_file *m = file->private_data;
@@ -106,6 +110,10 @@ static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root)) return 0;
+#endif
+
 	if (sb->s_op->show_devname) {
 		err = sb->s_op->show_devname(m, mnt_path.dentry);
 		if (err)
@@ -140,8 +148,25 @@ static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)
 	struct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root)) return 0;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (!uid_matches_proc_need_to_reorder_mnt_id()) goto orig_flow;
+
+	seq_printf(m, "%i %i %u:%u ",
+		susfs_get_fake_mnt_id(r->mnt_id),
+		susfs_get_fake_mnt_id(r->mnt_parent->mnt_id),
+		MAJOR(sb->s_dev), MINOR(sb->s_dev));
+	goto bypass_orig_flow;
+orig_flow:
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 	seq_printf(m, "%i %i %u:%u ", r->mnt_id, r->mnt_parent->mnt_id,
-		   MAJOR(sb->s_dev), MINOR(sb->s_dev));
+		MAJOR(sb->s_dev), MINOR(sb->s_dev));
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+bypass_orig_flow:
+#endif
 	if (sb->s_op->show_path) {
 		err = sb->s_op->show_path(m, mnt->mnt_root);
 		if (err)
@@ -202,6 +227,10 @@ static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)
 	struct super_block *sb = mnt_path.dentry->d_sb;
 	int err;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+	if (susfs_sus_mount(mnt, &p->root)) return 0;
+#endif
+
 	/* device */
 	if (sb->s_op->show_devname) {
 		seq_puts(m, "device ");
@@ -303,6 +332,11 @@ static int mounts_release(struct inode *inode, struct file *file)
 	path_put(&p->root);
 	mnt_cursor_del(p->ns, &p->cursor);
 	put_mnt_ns(p->ns);
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (uid_matches_proc_need_to_reorder_mnt_id()) {
+		susfs_remove_mnt_id_recorder();
+	}
+#endif
 	return seq_release_private(inode, file);
 }
 
@@ -313,6 +347,11 @@ static int mounts_open(struct inode *inode, struct file *file)
 
 static int mountinfo_open(struct inode *inode, struct file *file)
 {
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT_MNT_ID_REORDER
+	if (uid_matches_proc_need_to_reorder_mnt_id()) {
+		susfs_add_mnt_id_recorder();
+	}
+#endif
 	return mounts_open_common(inode, file, show_mountinfo);
 }
 
diff --git a/fs/readdir.c b/fs/readdir.c
index 09e8ed7d4..f56e7d99e 100644
--- a/fs/readdir.c
+++ b/fs/readdir.c
@@ -22,6 +22,10 @@
 #include <linux/compat.h>
 #include <linux/uaccess.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include <asm/unaligned.h>
 
 /*
@@ -326,6 +330,13 @@ static int filldir64(struct dir_context *ctx, const char *name, int namlen,
 	prev_reclen = buf->prev_reclen;
 	if (prev_reclen && signal_pending(current))
 		return -EINTR;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+        if (susfs_sus_ino_for_filldir64(ino)) {
+                return 0;
+        }
+#endif
+
 	dirent = buf->current_dir;
 	prev = (void __user *)dirent - prev_reclen;
 	if (!user_write_access_begin(prev, reclen + prev_reclen))
diff --git a/fs/stat.c b/fs/stat.c
index 3e5be6702..ccd29d76c 100644
--- a/fs/stat.c
+++ b/fs/stat.c
@@ -21,6 +21,10 @@
 #include <linux/uaccess.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include "internal.h"
 #include "mount.h"
 
@@ -154,6 +158,12 @@ int vfs_getattr(const struct path *path, struct kstat *stat,
 {
 	int retval;
 
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+	if (susfs_sus_path_by_path(path, &retval, SYSCALL_FAMILY_ALL_ENOENT)) {
+		return retval;
+	}
+#endif
+
 	retval = security_inode_getattr(path);
 	if (retval)
 		return retval;
@@ -515,6 +525,11 @@ static long cp_new_stat64(struct kstat *stat, struct stat64 __user *statbuf)
 	tmp.st_size = stat->size;
 	tmp.st_blocks = stat->blocks;
 	tmp.st_blksize = stat->blksize;
+
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+	susfs_sus_kstat(tmp.st_ino, &tmp);
+#endif
+
 	return copy_to_user(statbuf,&tmp,sizeof(tmp)) ? -EFAULT : 0;
 }
 
diff --git a/include/linux/mount.h b/include/linux/mount.h
index 9fc799307..84db4bbb4 100644
--- a/include/linux/mount.h
+++ b/include/linux/mount.h
@@ -122,6 +122,10 @@ extern dev_t name_to_dev_t(const char *name);
 
 extern unsigned int sysctl_mount_max;
 
+#ifdef CONFIG_KSU_SUSFS
+extern int path_umount(struct path *path, int flags);
+#endif
+
 extern bool path_is_mountpoint(const struct path *path);
 
 extern void kern_unmount_array(struct vfsmount *mnt[], unsigned int num);
diff --git a/kernel/sys.c b/kernel/sys.c
index 4b2ebf822..26a9910d5 100644
--- a/kernel/sys.c
+++ b/kernel/sys.c
@@ -73,6 +73,10 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/susfs.h>
+#endif
+
 #include "uid16.h"
 
 #include <trace/hooks/sys.h>
@@ -1304,6 +1308,11 @@ SYSCALL_DEFINE1(newuname, struct new_utsname __user *, name)
 	down_read(&uts_sem);
 	memcpy(&tmp, utsname(), sizeof(tmp));
 	up_read(&uts_sem);
+
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+	susfs_spoof_uname(&tmp);
+#endif
+
 	if (copy_to_user(name, &tmp, sizeof(tmp)))
 		return -EFAULT;
 
-- 
2.43.0

